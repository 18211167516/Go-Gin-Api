{"./":{"url":"./","title":"基本介绍","keywords":"","body":"1、项目说明 [!NOTE] 该项目为开源项目[Go-Gin-Api]项目文档 Go-Gin-Api 是基于 Gin 进行模块化设计的 API 框架，封装了常用的功能，使用简单，致力于进行快速的业务研发，v2.0支持后台管理，使用Light Year Admin 模板，至于说为啥不用前后端分离，使用vue，我觉得大部分后端程序员学习vue的成本还是很高的，公司会有专门的前端同学 powered by Gitbook该文件最后修改时间： 2021-10-24 17:32:05 "},"入门/":{"url":"入门/","title":"入门指南","keywords":"","body":"入门指南.md [!NOTE] 整体项目的环境安装、项目启动 希望你有所收获 powered by Gitbook该文件最后修改时间： 2021-10-24 17:40:25 "},"入门/docker-install.html":{"url":"入门/docker-install.html","title":"docker环境安装","keywords":"","body":"docker环境安装 1、docker更换阿里云镜像源 1.在windows命令行执行docker-machine ssh [machine-name]进入VM bash 2.sudo vi /var/lib/boot2docker/profile 3.在--label provider=virtualbox的下一行添加 --registry-mirror=https://k5paawyp.mirror.aliyuncs.com 4.重启docker服务： sudo /etc/init.d/docker restart或者重启VM：exit退出VM bash， 在windows命令行中执行docker-machine restart 5.直接执行命令：ggdocker-machine ssh default \"echo 'EXTRA_ARGS=\\\"--registry-mirror=https://k5paawyp.mirror.aliyuncs.com\\\"' sudo tee -a /var/lib/boot2dock er/profile\" docker-machine restart default 2、基于docker [!NOTE] 目录结构 ├─config （配置文件目录） | ├─conf.d （nginx的conf.d） | ├─mysql.cnf （mysql配置） | ├─redis.conf （redis配置） ├─log （日志目录） | ├─mysql （mysql日志） ├─mysql （mysql数据目录） ├─docker-compose.yaml （docker-composer） [!NOTE] docker-composer.yaml version: \"3\" services: mysql: image: mysql:5.6 ports: - \"3306:3306\" volumes: - ./conf/mysql.cnf:/etc/mysql/conf.d/mysql.cnf:ro - ./mysql:/var/lib/mysql/new/:rw - ./log/mysql/:/var/log/mysql/:rw restart: always networks: - default environment: MYSQL_ROOT_PASSWORD: \"123456\" TZ: \"$TZ\" redis: image: redis:5.0.3-alpine ports: - \"6379:6379\" volumes: - ./conf/redis.conf:/etc/redis.conf:ro restart: always entrypoint: [\"redis-server\", \"/etc/redis.conf\"] environment: TZ: \"TZ=Asia/Shanghai\" networks: - default memcached: image: memcached:latest ports: - \"11211:11211\" 3、docker-compose docker-compose up 编译并启动 docker-compose restart 重启容器 powered by Gitbook该文件最后修改时间： 2021-10-31 14:14:19 "},"入门/git.html":{"url":"入门/git.html","title":"项目配置以及启动","keywords":"","body":"git代码托管以及代码管理 git下载 git clone https://github.com/18211167516/Go-Gin-Api.git 初始化数据 cd cmd目录 go build -o cmd.exe 编译cmd工具 ./cmd.exe initdb 下载热编译工具 go get github.com/pilu/fresh 热编译项目 fresh 配置文件是当前项目下 runner.conf 编译项目并启动 make文章 1、使用go编译 go build . 2、windows下使用make命令,需要下载make 3、启动 登录后台 账号：admin 密码：Admin123 powered by Gitbook该文件最后修改时间： 2021-12-02 15:00:38 "},"技术选型/":{"url":"技术选型/","title":"技术选型","keywords":"","body":"1、项目说明 [!NOTE] 该项目为开源项目[Go-Gin-Api]项目文档 用Gin快速搭建基础restful风格API，Gin文档是一个go语言编写的Web框架 数据校验 go-playground github gin框架内置，已支持错误信息转中文 数据库：采用MySql(5.6.44)版本，使用gorm 文档实现对数据库的基本操作。 API文档：使用Swaggergithub构建自动化文档。 热重启HotStart github,我自己写的一个 配置文件 使用viper github解析 日志：使用zap github实现日志记录。 RBAC权限：使用casbin文档实现 安全Cookie:使用encryptgithub实现加密解密 powered by Gitbook该文件最后修改时间： 2021-10-31 16:18:33 "},"核心架构/":{"url":"核心架构/","title":"项目架构","keywords":"","body":" [!TIP] 整体架构 1、目录结构 ├─app （项目核心目录） | ├─controller （控制器） | ├─middleware （中间件） | ├─models （数据结构层） | ├─request （数据请求层，定义特殊请求结构体以及数据校验） | ├─request （数据展示层定义结构体） | ├─services （服务层） ├─config （配置包） ├─core （內核、项目核心库） ├─docs （swagger文档目录） ├─global （全局变量） ├─initialize (初始化) ├─routes （路由） ├─static （静态文件包括config目录） ├─templates （模板目录） ├─tests （测试） └─tool （工具包） 2、组件支持 支持Swagger接口文档生成 支持jwt鉴权 支持logrus(准备替换成zap) 支持viper 配置文件解析 支持go1.6.0 go:embed特性,打包包含静态文件 支持gorm 数据库组件、支持读写分离，数据库主从 支持web界面 使用 Light Year Admin 模板 支持支持多角色的RBAC权限控制[支持按钮级权限控制]，使用casbin 支持工具快速生成controller、model、service、view 支持热编译fresh powered by Gitbook该文件最后修改时间： 2021-12-02 17:55:41 "},"功能/":{"url":"功能/","title":"基础功能","keywords":"","body":" [!NOTE] 主要看自实现的一些核心功能 powered by Gitbook该文件最后修改时间： 2021-10-24 18:08:53 "},"功能/配置.html":{"url":"功能/配置.html","title":"配置","keywords":"","body":" [!NOTE] 配置文件的解析主要采用了viper 项目内主要采用了2种方式获取配置值 支持默认的配置文件以及命令设置配置文件 项目支持go1.16embed特性，也就是会把配置文件打包到项目里 同时支持监听配置文件的修改，修改时自动加载新的配置 关于配置初始化代码：core.Viper() 我们以获取log的配置为例： 通过结构体获取 结构体主要定义在config目录下，核心是config.go import (\"go-api/global\") global.CF.Log.LogInConsole 通过viper的Get系列方法 import (\"go-api/global\") global.VP.GetBool(\"log.LogInConsole\") powered by Gitbook该文件最后修改时间： 2021-10-31 16:40:37 "},"功能/路由.html":{"url":"功能/路由.html","title":"路由","keywords":"","body":" [!NOTE] gin采用httprouter实现路由 项目路由文件routes目录下 核心注册文件routes/route.go 介绍路由的基本用法 基本路由 路由器允许你注册能响应任何 HTTP 请求的路由： router.Any(path, ...HandlerFunc) router.GET(path, ...HandlerFunc) router.POST(path, ...HandlerFunc) router.DELETE(path, ...HandlerFunc) router.PATCH(path, ...HandlerFunc) router.PUT(path, ...HandlerFunc) router.OPTIONS(path, ...HandlerFunc) router.HEAD(path, ...HandlerFunc) 路由参数 // 此 handler 将匹配 /user/john/ 和 /user/john/send router.GET(\"/user/:name/*action\", func(c *gin.Context) { name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) }) 静态文件路由 本项目采用 r.StaticFS(\"/public\", http.FS(f)) // example: /public/static/js/a.js router := gin.Default() router.Static(\"/assets\", \"./assets\") router.StaticFS(\"/more_static\", http.Dir(\"my_file_system\")) router.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\") 路由组 router := gin.Default() // 简单的路由组: v1 v1 := router.Group(\"/v1\") { v1.POST(\"/login\", loginEndpoint) v1.POST(\"/submit\", submitEndpoint) v1.POST(\"/read\", readEndpoint) } 重定向 http重定向 r.GET(\"/test\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"http://www.google.com/\") }) 路由重定向 r.GET(\"/test\", func(c *gin.Context) { c.Request.URL.Path = \"/test2\" r.HandleContext(c) }) r.GET(\"/test2\", func(c *gin.Context) { c.JSON(200, gin.H{\"hello\": \"world\"}) }) powered by Gitbook该文件最后修改时间： 2021-12-02 10:36:59 "},"功能/中间件.html":{"url":"功能/中间件.html","title":"中间件","keywords":"","body":" [!NOTE] 中间件为过滤进入应用程序的 HTTP 请求提供了一种方便的机制 项目内置了logger,recovery,404,checkLogin,rbac等中间件 所有中间件目前都位于app/middleware目录下 定义中间件 在app/middleware下新建文件 package定义为middleware func Casbin_rbac() gin.HandlerFunc { return func(c *gin.Context) { c.Abort()//阻断 c.Next()//继续执行 } } 为路由设置中间件 定义好中间件后到路由文件使用Use方法 例如routes/admin.go 中间件参数 我们可以拿到gin.Context的参数 func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // 设置 example 变量 c.Set(\"example\", \"12345\") // 请求前 c.Next() // 请求后 latency := time.Since(t) log.Print(latency) // 获取发送的 status status := c.Writer.Status() log.Println(status) } } 中间件的执行流程 func Logger() gin.HandlerFunc { return func(c *gin.Context) { log.Println(\"请求前\") c.Next() // 请求后 log.Println(\"请求后\") } } powered by Gitbook该文件最后修改时间： 2021-10-31 17:29:21 "},"功能/控制器.html":{"url":"功能/控制器.html","title":"控制器","keywords":"","body":" [!NOTE] 项目控制器文件app/controller目录下，当然有需要的话可以在加文件夹 介绍控制器的基本用法 所有的控制器方法和中间件均要实现gin框架接口type HandlerFunc func(*Context) 错误码以及输出方式和输出数据格式均在tool包定义 输出json数据 func Controller(c *gin.Context) { tool.JSONP(c, 0, \"成功\", \"我是数据\") } 输出视图 func Controller(c *gin.Context) { tool.HTML(c, \"视图名\", tool.M{}) } powered by Gitbook该文件最后修改时间： 2021-10-31 17:42:43 "},"功能/视图.html":{"url":"功能/视图.html","title":"模板视图","keywords":"","body":" [!NOTE] 项目启用视图在routes/file.go 模板文件定义在templates目录 基于go1.16之后embed特性，我们打包的时候会把模板文件也一起打包 设置模板目录 func fileRoute(r *gin.Engine) { f := global.FS templ := template.Must(template.New(\"\").Funcs(Funcs).ParseFS(f, \"templates/*/*\")) r.SetHTMLTemplate(templ) // example: /public/static/js/a.js r.StaticFS(\"/public\", http.FS(f)) } 在控制器输出视图 [!NOTE] 定义控制器 func PostController(c *gin.Context) { tool.HTML(c, \"posts/index.tmpl\", tool.M{\"title\":\"posts\"}) } [!NOTE] 定义路由 router.GET(\"/posts/index\", controller.PostController) [!NOTE] 定义模板 因为排版原因 { } 替换成 { { } } {define \"posts/index.tmpl\"} {.title} Using posts/index.tmpl end 模板嵌套 [!NOTE] 定义模板1 { define \"common/header\" } Using header { end } [!NOTE] 定义模板2 { define \"posts/index.tmpl\" } {template \"common/header\" .} { .title } Using posts/index.tmpl { end } 模板用法 [!NOTE] define { define \"name\" } T { end } [!NOTE] template 第一种是直接执行名为name的模板，模板的全局数据对象.设置为nil。第二种是点.设置为title的值，并执行名为name的模板。 { template \"name\" } { template \"name\" .title } [!NOTE] block 的语义是如果有命名为 name 的模板，就引用过来执行，如果没有命名为 name 的模板，就是执行自己定义的内容。换句话说，block可以认为是设置一个默认模板 { block \"name\" pipeline } T1 { end } [!NOTE] with 创建一个新的上下文环境，在此环境中的 . 与外面的 . 无关。 对于第一种格式，当pipeline不为0值的时候，点.设置为pipeline运算的值，否则跳过。对于第二种格式，当pipeline为0值时，执行else语句块，否则.设置为pipeline运算的值，并执行T1。 { with pipeline } T1 { end } // 如果 pipeline 是空值则输出 T0 { with pipeline } T1 { else } T0 { end } { with arg } . // 此时 . 就是 arg { end } [!NOTE] 输出变量 { .title } [!NOTE] 条件语句 { if pipeline } T1 { end } { if pipeline } T1 { else } T0 { end } { if pipeline } T1 { else if pipeline } T0 { end } // 上面的语法其实是下面的简写 { if pipeline } T1 { else }{ if pipeline } T0 { {end }{ end } { if pipeline } T1 { else if pipeline } T2 { else } T0 { end } [!NOTE] 循环语句 { range pipeline } T1 { end } // 这个 else 比较有意思，如果 pipeline 的长度为 0 则输出 else 中的内容 { range pipeline } T1 { else } T0 { end } // 获取容器的下标 { range $index, $value := pipeline } T1 { end } 模板方法 [!NOTE] 字段 {.} 表示当前字段 {.Name} 表示某个结构体的 Name 字段 结构体字段需能被外部访问：即 字段首字母大写 [!NOTE] 自定义方法 在routes/file.go定义参考DefaultValueFunc 同时添加到Funcs [!NOTE] 内置函数 call 执行方法 ，返回参数必须是1个或2个， { call call .funtion .param} [!NOTE] not 非 {if not .condition} {end} [!NOTE] and 与 {if and .condition1 .condition2} {end} [!NOTE] or 或 {if or .condition1 .condition2} {end} [!NOTE] eq 判断相等 {if eq .content1 .content2} {end} [!NOTE] ne 不等于 {if ne .var1 .var2} {end} [!NOTE] lt 小于 {if lt .var1 .var2} {end} [!NOTE] le 小于等于 {if le .var1 .var2} {end} [!NOTE] gt 大于 {if gt .var1 .var2} {end} [!NOTE] ge 大于等于 {if ge .var1 .var2} {end} [!NOTE] 打印 {\"你好\"|print \"世界\"} // fmt.Sprint 的别名 {\"你好\"|printf \"%d %s\" 123} // Spintf的别名 {\"你好\"|println \"世界\"} // Println [!NOTE] len 长度 {\"hello\"|len} // 返回参数的长度 [!NOTE] html转义 { \"\"|html} // 转义文本中html的标签 [!NOTE] 返回用js的escape处理后的文本, 自动进行html转义 { \"?a=123&b=\"你好\"|js} [!NOTE] urlquery url编码 {?q=关键字&p=1|urlquery} // 进行url编码 powered by Gitbook该文件最后修改时间： 2021-12-02 10:52:17 "},"功能/表单验证.html":{"url":"功能/表单验证.html","title":"表单验证","keywords":"","body":" [!NOTE] 项目验证规则文件在app/request目录下 使用的gin自带的go-playground/validator包，支持汉化，同时为了便捷实用我们做了改造，不需要再model层结构体加验证的tag 支持结构体、map、单个变量验证 介绍表单验证的基本用法 1、在request定义规则 package request var ( AddVerify = Rules{} UpVerify = Rules{\"ID\": \"required,numeric,min=1\"} DelVerify = Rules{\"ID\": \"required,numeric,min=1\"} ) 2、在控制器验证 var rule models.SysRule c.ShouldBindUri(&rule) if err := request.Verify(rule, request.DelVerify); err != nil { tool.JSONP(c, 400, err.Error(), nil) return } 3、可用验证规则 [!NOTE] 范围约束 len：等于参数值，例如len=10； max：小于等于参数值，例如max=10； min：大于等于参数值，例如min=10； eq：等于参数值，注意与len不同。对于字符串，eq约束字符串本身的值，而len约束字符串长度。例如eq=10； ne：不等于参数值，例如ne=10； gt：大于参数值，例如gt=10； gte：大于等于参数值，例如gte=10； lt：小于参数值，例如lt=10； lte：小于等于参数值，例如lte=10； oneof：只能是列举出的值其中一个，这些值必须是数值或字符串，以空格分隔，如果字符串中有空格，将字符串用单引号包围，例如oneof=red green。 [!NOTE] 跨字段约束 这个在我们的验证器中无法使用，只能单独使用 if err := request.VerifyValue(user.Password, user.ConfirmPassword, \"eqfield\"); err != nil { tool.JSONP(c, 400, \"确认密码和新密码不一致\", nil) return } eqfield:同一结构体字段相等Field 例：validate:\"eqfield=Field2\" nefield:同一结构体字段不相等Field 例：validate:\"nefield=Field2\" gtfield:大于同一结构体字段Field 例：validate:\"gtfield=Field2\" gtefield:大于等于同一结构体字段Field 例：validate:\"gtefield=Field2\" ltfield:小于同一结构体字段Field 例：validate:\"ltfield=Field2\" ltefield:小于等于同一结构体字段Field 例：validate:\"ltefield=Field2\" eqcsfield:跨不同结构体字段相等Struct1.Field 例：validate:\"eqcsfield=Struct2.Field2\" necsfield:跨不同结构体字段不相等Struct1.Field 例：validate:\"necsfield=Struct2.Field2\" gtcsfield:大于跨不同结构体字段Struct1.Field 例：validate:\"gtcsfield=Struct2.Field2\" gtecsfield:大于等于跨不同结构体字段Struct1.Field 例：validate:\"gtecsfield=Struct2.Field2\" ltcsfield:小于跨不同结构体字段Struct1.Field 例：validate:\"ltcsfield=Struct2.Field2\" ltecsfield:小于等于跨不同结构体字段Struct1.Field 例：validate:\"ltecsfield=Struct2.Field2\" [!NOTE] 字符串约束 contains=：包含参数子串，例如contains=email； containsany：包含参数中任意的 UNICODE 字符，例如containsany=abcd； containsrune：包含参数表示的 rune 字符，例如containsrune=☻； excludes：不包含参数子串，例如excludes=email； excludesall：不包含参数中任意的 UNICODE 字符，例如excludesall=abcd； excludesrune：不包含参数表示的 rune 字符，excludesrune=☻； startswith：以参数子串为前缀，例如startswith=hello； endswith：以参数子串为后缀，例如endswith=bye。 [!NOTE] 特殊约束 -：跳过该字段，不检验； |：使用多个约束，只需要满足其中一个，例 rgb|rgba； required：字段必须设置，不能为默认值； omitempty：如果字段未设置，则忽略它。 ip:字符串值是否包含有效的IP地址 例 Field validate:\"ip\" ipv4:字符串值是否包含有效的ipv4地址 例 Field validate:\"ipv4\" datetime:字符串值是否包含有效的日期 例 Field validate:\"datetime\" [!NOTE] 自定义约束 建议写在request/zh.go,如果需要自定义请参考该文件 checkMobile:校验手机号 checkPassword:校验密码 powered by Gitbook该文件最后修改时间： 2021-12-02 15:44:38 "},"功能/session.html":{"url":"功能/session.html","title":"session","keywords":"","body":" [!NOTE] 核心代码位于在core/session目录下 使用包github.com/18211167516/sessions 是我fork的github.com/gorilla/sessions 建议各位在使用别人的包尽量要fork下来，方便调试和优化 结构 ├─middleware （中间件） | StartSession.go （开启session中间件） ├─stores （多存储实现方式、可自定义） | cookieStore.go （cookie存储） | redisStore.go （redis存储） | store.go （定义的store接口，自定义均要实现该接口） ├─session.go （session实现） 使用 package routes import ( \"go-api/app/middleware\" \"go-api/app/response\" \"go-api/core/session\" coremiddleware \"go-api/core/session/middleware\" \"go-api/tool\" \"github.com/gin-gonic/gin\" ) func testRoute(r *gin.Engine) { test := r.Group(\"/test\", middleware.DefaultLog(), middleware.Recovery(), coremiddleware.StartSession()) { test.GET(\"/panic\", func(c *gin.Context) { box := response.SysLoginUserResponse{ ID: \"1\", Name: \"白\", RealName: \"Bai\", Type: 2, Password: \"string\", } s := session.Default(c) count := s.Get(\"user\") s.Set(\"user\", tool.StructToJson(box)) s.Save() tool.JSONP(c, 0, \"层高\", count) }) } } 支持方法 [!NOTE] 实例化sesssion func NewSession(c *gin.Context, store stores.Store) *session { } [!NOTE] 获取sesssion func Default(c *gin.Context) Session { return c.MustGet(global.VP.GetString(\"session.cookie\")).(Session) } [!NOTE] 获取值 func (s *session) Get(key interface{}) interface{} {} [!NOTE] 设置值 func (s *session) Set(key interface{}, val interface{}) {} [!NOTE] 删除值 func (s *session) Delete(key interface{}) {} [!NOTE] 清空session func (s *session) Clear() {} [!NOTE] 保存值 func (s *session) Save() error {} 自定义store 需要实现 接口 ``` type Store interface { // Get should return a cached session. Get(r http.Request, name string) (Session, error) // New should create and return a new session. // // Note that New should never return a nil session, even in the case of // an error if using the Registry infrastructure to cache the session. New(r *http.Request, name string) (*Session, error) // Save should persist session to the underlying store implementation. Save(r *http.Request, w http.ResponseWriter, s *Session) error } ``` powered by Gitbook该文件最后修改时间： 2021-12-02 18:47:00 "},"功能/错误.html":{"url":"功能/错误.html","title":"错误","keywords":"","body":" [!NOTE] 项目验证规则文件在app/request目录下 使用的gin自带的go-playground/validator包，支持汉化，同时为了便捷实用我们做了改造，不需要再model层结构体加验证的tag 支持结构体、map、单个变量验证 介绍表单验证的基本用法 powered by Gitbook该文件最后修改时间： 2021-12-02 17:08:43 "},"功能/统一返回.html":{"url":"功能/统一返回.html","title":"统一返回","keywords":"","body":"powered by Gitbook该文件最后修改时间： 2021-12-02 17:09:18 "},"功能/日志.html":{"url":"功能/日志.html","title":"日志","keywords":"","body":"powered by Gitbook该文件最后修改时间： 2021-12-02 17:09:13 "},"前端/":{"url":"前端/","title":"前端开发","keywords":"","body":" [!NOTE] 待完善 powered by Gitbook该文件最后修改时间： 2021-12-02 17:51:31 "},"安全/":{"url":"安全/","title":"安全相关","keywords":"","body":" [!NOTE] 待完善 powered by Gitbook该文件最后修改时间： 2021-12-02 17:51:31 "},"综合话题/":{"url":"综合话题/","title":"综合话题","keywords":"","body":" [!NOTE] 待完善 powered by Gitbook该文件最后修改时间： 2021-12-02 17:51:31 "},"数据库/":{"url":"数据库/","title":"数据库","keywords":"","body":" [!NOTE] 待完善 powered by Gitbook该文件最后修改时间： 2021-12-02 17:51:31 "},"联系方式/":{"url":"联系方式/","title":"联系方式","keywords":"","body":" [!NOTE] 作者个人联系方式 powered by Gitbook该文件最后修改时间： 2021-10-24 18:28:33 "}}