{"./":{"url":"./","title":"基本介绍","keywords":"","body":"1、项目说明 [!NOTE] 该项目为开源项目[Go-Gin-Api]项目文档 Go-Gin-Api 是基于 Gin 进行模块化设计的 API 框架，封装了常用的功能，使用简单，致力于进行快速的业务研发，v2.0支持后台管理，使用Light Year Admin 模板，至于说为啥不用前后端分离，使用vue，我觉得大部分后端程序员学习vue的成本还是很高的，公司会有专门的前端同学 powered by Gitbook该文件最后修改时间： 2021-10-24 17:32:05 "},"入门/":{"url":"入门/","title":"入门指南","keywords":"","body":"入门指南.md [!NOTE] 整体项目的环境安装、项目启动 希望你有所收获 powered by Gitbook该文件最后修改时间： 2021-10-24 17:40:25 "},"入门/docker-install.html":{"url":"入门/docker-install.html","title":"docker环境安装","keywords":"","body":"docker环境安装 1、docker更换阿里云镜像源 1.在windows命令行执行docker-machine ssh [machine-name]进入VM bash 2.sudo vi /var/lib/boot2docker/profile 3.在--label provider=virtualbox的下一行添加 --registry-mirror=https://k5paawyp.mirror.aliyuncs.com 4.重启docker服务： sudo /etc/init.d/docker restart或者重启VM：exit退出VM bash， 在windows命令行中执行docker-machine restart 5.直接执行命令：ggdocker-machine ssh default \"echo 'EXTRA_ARGS=\\\"--registry-mirror=https://k5paawyp.mirror.aliyuncs.com\\\"' sudo tee -a /var/lib/boot2dock er/profile\" docker-machine restart default 2、基于docker [!NOTE] 目录结构 ├─config （配置文件目录） | ├─conf.d （nginx的conf.d） | ├─mysql.cnf （mysql配置） | ├─redis.conf （redis配置） ├─log （日志目录） | ├─mysql （mysql日志） ├─mysql （mysql数据目录） ├─docker-compose.yaml （docker-composer） [!NOTE] docker-composer.yaml version: \"3\" services: mysql: image: mysql:5.6 ports: - \"3306:3306\" volumes: - ./conf/mysql.cnf:/etc/mysql/conf.d/mysql.cnf:ro - ./mysql:/var/lib/mysql/new/:rw - ./log/mysql/:/var/log/mysql/:rw restart: always networks: - default environment: MYSQL_ROOT_PASSWORD: \"123456\" TZ: \"$TZ\" redis: image: redis:5.0.3-alpine ports: - \"6379:6379\" volumes: - ./conf/redis.conf:/etc/redis.conf:ro restart: always entrypoint: [\"redis-server\", \"/etc/redis.conf\"] environment: TZ: \"TZ=Asia/Shanghai\" networks: - default memcached: image: memcached:latest ports: - \"11211:11211\" 3、docker-compose docker-compose up 编译并启动 docker-compose restart 重启容器 powered by Gitbook该文件最后修改时间： 2021-10-31 14:14:19 "},"入门/git.html":{"url":"入门/git.html","title":"项目配置以及启动","keywords":"","body":"git代码托管以及代码管理 [!TIP] git下载 git clone https://github.com/18211167516/Go-Gin-Api.git [!TIP] 导入并执行sql文件 static/config/init.sql [!TIP] 下载热编译工具 go get github.com/pilu/fresh [!TIP] 热编译项目 fresh 配置文件是当前项目下 runner.conf [!TIP] 编译项目并启动 make文章 1、使用go编译 go build . 2、windows下使用make命令,需要下载make 3、启动 [!TIP] 登录后台 账号：admin 密码：Admin123 powered by Gitbook该文件最后修改时间： 2021-10-24 18:00:48 "},"技术选型/":{"url":"技术选型/","title":"技术选型","keywords":"","body":"1、项目说明 [!NOTE] 该项目为开源项目[Go-Gin-Api]项目文档 用Gin快速搭建基础restful风格API，Gin文档是一个go语言编写的Web框架 数据校验 go-playground github gin框架内置，已支持错误信息转中文 数据库：采用MySql(5.6.44)版本，使用gorm 文档实现对数据库的基本操作。 API文档：使用Swaggergithub构建自动化文档。 热重启HotStart github,我自己写的一个 配置文件 使用viper github解析 日志：使用zap github实现日志记录。 RBAC权限：使用casbin文档实现 安全Cookie:使用encryptgithub实现加密解密 powered by Gitbook该文件最后修改时间： 2021-10-31 16:18:33 "},"核心架构/":{"url":"核心架构/","title":"项目架构","keywords":"","body":" [!TIP] 整体架构 1、目录结构 ├─app （项目核心目录） | ├─controller （控制器） | ├─middleware （中间件） | ├─models （数据结构层） | ├─request （数据请求层，定义特殊请求结构体以及数据校验） | ├─request （数据展示层定义结构体） | ├─services （服务层） ├─config （配置包） ├─core （內核） ├─docs （swagger文档目录） ├─global （全局变量） ├─initialize (初始化) ├─routes （路由） ├─static （静态文件包括config目录） ├─templates （模板） ├─tests （测试） └─tool （工具） 2、组件支持 支持Swagger接口文档生成 支持jwt鉴权 支持logrus(准备替换成zap) 支持viper 配置文件解析 支持go1.6.0 go:embed特性,打包包含静态文件 支持gorm 数据库组件、支持读写分离，数据库主从 支持web界面 使用 Light Year Admin 模板 支持支持多角色的RBAC权限控制，使用casbin 后续支持工具生成项目 支持热编译fresh powered by Gitbook该文件最后修改时间： 2021-10-24 18:05:10 "},"功能/":{"url":"功能/","title":"基础功能","keywords":"","body":" [!NOTE] 主要看自实现的一些核心功能 powered by Gitbook该文件最后修改时间： 2021-10-24 18:08:53 "},"功能/配置.html":{"url":"功能/配置.html","title":"配置","keywords":"","body":" [!NOTE] 配置文件的解析主要采用了viper 项目内主要采用了2种方式获取配置值 支持默认的配置文件以及命令设置配置文件 项目支持go1.16embed特性，也就是会把配置文件打包到项目里 同时支持监听配置文件的修改，修改时自动加载新的配置 关于配置初始化代码：core.Viper() 我们以获取log的配置为例： 通过结构体获取 结构体主要定义在config目录下，核心是config.go import (\"go-api/global\") global.CF.Log.LogInConsole 通过viper的Get系列方法 import (\"go-api/global\") global.VP.GetBool(\"log.LogInConsole\") powered by Gitbook该文件最后修改时间： 2021-10-31 16:40:37 "},"功能/路由.html":{"url":"功能/路由.html","title":"路由","keywords":"","body":" [!NOTE] gin采用httprouter实现路由 项目路由文件routes目录下 核心注册文件routes/route.go 介绍路由的基本用法 基本路由 路由器允许你注册能响应任何 HTTP 请求的路由： router.Any(path, ...HandlerFunc) router.GET(path, ...HandlerFunc) router.POST(path, ...HandlerFunc) router.DELETE(path, ...HandlerFunc) router.PATCH(path, ...HandlerFunc) router.PUT(path, ...HandlerFunc) router.OPTIONS(path, ...HandlerFunc) router.HEAD(path, ...HandlerFunc) 路由参数 // 此 handler 将匹配 /user/john/ 和 /user/john/send router.GET(\"/user/:name/*action\", func(c *gin.Context) { name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) }) 静态文件路由 本项目采用 r.StaticFS(\"/public\", http.FS(f)) // example: /public/static/js/a.js router := gin.Default() router.Static(\"/assets\", \"./assets\") router.StaticFS(\"/more_static\", http.Dir(\"my_file_system\")) router.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\") 路由组 router := gin.Default() // 简单的路由组: v1 v1 := router.Group(\"/v1\") { v1.POST(\"/login\", loginEndpoint) v1.POST(\"/submit\", submitEndpoint) v1.POST(\"/read\", readEndpoint) } 重定向 http重定向 r.GET(\"/test\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"http://www.google.com/\") }) 路由重定向 r.GET(\"/test\", func(c *gin.Context) { c.Request.URL.Path = \"/test2\" r.HandleContext(c) }) r.GET(\"/test2\", func(c *gin.Context) { c.JSON(200, gin.H{\"hello\": \"world\"}) }) powered by Gitbook该文件最后修改时间： 2021-10-31 17:59:09 "},"功能/中间件.html":{"url":"功能/中间件.html","title":"中间件","keywords":"","body":" [!NOTE] 中间件为过滤进入应用程序的 HTTP 请求提供了一种方便的机制 项目内置了logger,recovery,404,checkLogin,rbac等中间件 所有中间件目前都位于app/middleware目录下 定义中间件 在app/middleware下新建文件 package定义为middleware func Casbin_rbac() gin.HandlerFunc { return func(c *gin.Context) { c.Abort()//阻断 c.Next()//继续执行 } } 为路由设置中间件 定义好中间件后到路由文件使用Use方法 例如routes/admin.go 中间件参数 我们可以拿到gin.Context的参数 func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // 设置 example 变量 c.Set(\"example\", \"12345\") // 请求前 c.Next() // 请求后 latency := time.Since(t) log.Print(latency) // 获取发送的 status status := c.Writer.Status() log.Println(status) } } 中间件的执行流程 func Logger() gin.HandlerFunc { return func(c *gin.Context) { log.Println(\"请求前\") c.Next() // 请求后 log.Println(\"请求后\") } } powered by Gitbook该文件最后修改时间： 2021-10-31 17:29:21 "},"功能/控制器.html":{"url":"功能/控制器.html","title":"控制器","keywords":"","body":" [!NOTE] 项目控制器文件app/controller目录下，当然有需要的话可以在加文件夹 介绍控制器的基本用法 所有的控制器方法和中间件均要实现gin框架接口type HandlerFunc func(*Context) 错误码以及输出方式和输出数据格式均在tool包定义 输出json数据 func Controller(c *gin.Context) { tool.JSONP(c, 0, \"成功\", \"我是数据\") } 输出视图 func Controller(c *gin.Context) { tool.HTML(c, \"视图名\", tool.M{}) } powered by Gitbook该文件最后修改时间： 2021-10-31 17:42:43 "},"功能/视图.html":{"url":"功能/视图.html","title":"模板视图","keywords":"","body":" [!NOTE] 项目启用视图在routes/file.go 模板文件定义在templates目录 基于go1.16之后embed特性，我们打包的时候会把模板文件也一起打包 设置魔板目录 func fileRoute(r *gin.Engine) { f := global.FS templ := template.Must(template.New(\"\").Funcs(Funcs).ParseFS(f, \"templates/*/*\")) r.SetHTMLTemplate(templ) // example: /public/static/js/a.js r.StaticFS(\"/public\", http.FS(f)) } 在控制器输出视图 定义控制器 func PostController(c *gin.Context) { tool.HTML(c, \"posts/index.tmpl\", tool.M{\"title\":\"posts\"}) } 定义路由 router.GET(\"/posts/index\", controller.PostController) 定义模板 因为排版原因 { } 替换成 { { } } {define \"posts/index.tmpl\"} {.title} Using posts/index.tmpl end 模板嵌套 定义模板1 { define \"common/header\" } Using header { end } 定义模板2 { define \"posts/index.tmpl\" } {template \"common/header\" .} { .title } Using posts/index.tmpl { end } 模板用法 define { define \"name\" } T { end } template 第一种是直接执行名为name的模板，模板的全局数据对象.设置为nil。第二种是点.设置为title的值，并执行名为name的模板。 { template \"name\" } { template \"name\" .title } block block 的语义是如果有命名为 name 的模板，就引用过来执行，如果没有命名为 name 的模板，就是执行自己定义的内容。换句话说，block可以认为是设置一个默认模板 { block \"name\" pipeline } T1 { end } with with 创建一个新的上下文环境，在此环境中的 . 与外面的 . 无关。 对于第一种格式，当pipeline不为0值的时候，点.设置为pipeline运算的值，否则跳过。对于第二种格式，当pipeline为0值时，执行else语句块，否则.设置为pipeline运算的值，并执行T1。 { with pipeline } T1 { end } // 如果 pipeline 是空值则输出 T0 { with pipeline } T1 { else } T0 { end } { with arg } . // 此时 . 就是 arg { end } 输出变量 { .title } 条件语句 { if pipeline } T1 { end } { if pipeline } T1 { else } T0 { end } { if pipeline } T1 { else if pipeline } T0 { end } // 上面的语法其实是下面的简写 { if pipeline } T1 { else }{ if pipeline } T0 { {end }{ end } { if pipeline } T1 { else if pipeline } T2 { else } T0 { end } 循环语句 { range pipeline } T1 { end } // 这个 else 比较有意思，如果 pipeline 的长度为 0 则输出 else 中的内容 { range pipeline } T1 { else } T0 { end } // 获取容器的下标 { range $index, $value := pipeline } T1 { end } 模板方法 字段 ```{.} 表示当前字段 {.Name} 表示某个结构体的 Name 字段 结构体字段需能被外部访问：即 字段首字母大写 #### 自定义 > 在`routes/file.go`定义参考`DefaultValueFunc` > 同时添加到Funcs #### 内置函数 > call 执行方法 ，返回参数必须是1个或2个， { call call .funtion .param} > not 非 {if not .condition} {end} > and 与 {if and .condition1 .condition2} {end} > or 或 {if or .condition1 .condition2} {end} > eq 判断相等 {if eq .content1 .content2} {end} > ne 不等于 {if ne .var1 .var2} {end} > lt 小于 {if lt .var1 .var2} {end} > le 小于等于 {if le .var1 .var2} {end} > gt 大于 {if gt .var1 .var2} {end} > ge 大于等于 {if ge .var1 .var2} {end} > 打印 {\"你好\"|print \"世界\"} // fmt.Sprint 的别名 {\"你好\"|printf \"%d %s\" 123} // Spintf的别名 {\"你好\"|println \"世界\"} // Println > len 长度 {\"hello\"|len} // 返回参数的长度 > html转义 { \"\"|html} // 转义文本中html的标签 > 返回用js的escape处理后的文本, 自动进行html转义 { \"?a=123&b=\"你好\"|js} > urlquery url编码 {?q=关键字&p=1|urlquery} // 进行url编码 ``` powered by Gitbook该文件最后修改时间： 2021-10-31 18:42:46 "},"联系方式/":{"url":"联系方式/","title":"联系方式","keywords":"","body":" [!NOTE] 作者个人联系方式 powered by Gitbook该文件最后修改时间： 2021-10-24 18:28:33 "}}